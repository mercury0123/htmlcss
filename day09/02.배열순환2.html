<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>배열순환2</title>
</head>
<body>
    <h1>
        배열의 순환할 수 있는 구조를 이용하여 특정기능을 할 수 있는 메소드가 제공됨
    </h1>
    <ul>
        <li>    <!-- total은 누적값 -->
            array.reduce(callback function(total, value, index, self),[init value초기값 선언]) 
            : 내부 연산의 누적값을 리턴
        </li>
        <li>
            array.reduceRight(reduce와 동일) 
            : 배열의 값을 우측에서 좌측방향으로 대입
        </li>
        <li>
            array.every(callback function(value, index, self)) 
            : 콜백함수의 리턴조건에 만족하는 배열값이 만족하면 true 리턴, 아니면 false 리턴
        </li>
        <li>
            array.some(callback function(value, index, self)) 
            : 콜백함수의 리턴조건에 만족하는 배열값이 존재하면 true 리턴, 아니면 false 리턴
        </li>
        <li>
            array.indexOf("srt",[start index]) 
            : 배열의 값 중 해당하는 문자열이 있는 배열의 마지막 index를 리턴함
        </li>
        <li>
            array.find(callback function(value, index, self))
            : 콜백 함수의 리턴조건에 만족하는 첫번째 배열원소의 index를 리턴함
        </li>
        <li>
            array.from('sequence architecture가 적용된 객체')
            : 순서가 있거나 순환 구조를 가지고 있는 객체를 배열로 변환
        </li>
        <li>
            array.keys() : 배열이 사용중인 key(식별자,index)를 검색하여 새로운 배열로 리턴
            => 객체에는 적용안됨
        </li>
        <li>
            array.entries() : 배열의 index:value의 구조값을 만들어 새로운 배열에 담아 리턴
            => 객체에는 적용안됨
        </li>
        <li>
            array.includes("찾고싶은 값") : 배열에 찾는 값이 존재하면 true를 리턴
        </li>        
    </ul>
    <hr>
    <p id="lecture"></p>

    <script>
        const fruits = ['apple','banana','orange','kiwi'];
        
        document.getElementById("lecture").innerHTML = `${fruits.includes("apple")} <br>`;  //apple 이 있는가?
        document.getElementById("lecture").innerHTML += `${fruits.indexOf("apple")} <br>`;  //apple 위치는?
        document.getElementById("lecture").innerHTML += `${fruits.indexOf("kiwi")} <br>`;   //kiwi 찾기

        const numArr = [1,2,3,4,5,6,7,8,9,10];
        const sum = numArr.reduce((p,c,index,numArr)=>(p+c));
        //0 = 1
        //1 = 2
        document.getElementById("lecture").innerHTML += `${sum} <br>`;

        //find함수 : 해당 조건을 만족하는 가장 첫번째 값을 리턴
        //findIndex : 해당 조건을 만족하는 가장 첫번째 인덱스 리턴
        console.log('------------------find');
        console.log(numArr.find(el=>el>5));
        console.log(numArr.findIndex(el=>el>5));
        
        //some : 요소가 주어진 조건을 통과하는 값이 1개 이상이면 true
        //numArr 에서 짝수가 있는지 체크
        console.log('------------------some');        
        const even1 = numArr.some(el=>el%2==0);
        console.log(even1);

        console.log('-----------------every');        
        const even2 = numArr.some(el=>el%2==0);
        console.log(even2);
        const over = numArr.some(el=>el <5);
        console.log(over);

        //배열의 index만 추출
        console.log('------------------keys');
        const f = fruits.keys();
        for (let a of f) {
            
            console.log(a);
        }
        //배열의 인덱스와 그 인덱스의 요소 추출    
        console.log('----------------entries');
        const e = fruits.entries();
        for (let b of e) {
            console.log(typeof b);
            console.log(b);
        }

        const obj = {
            a:1,
            b:2,
            c:3,
            d:4
        };

        // const objEntry = obj.entries();
        // for( const o in obj){
        //     console.log(o);            
        // }
        // //객체라서 사용이 안됨

    </script>
</body>
</html>